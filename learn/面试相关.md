个人介绍：
     Hello, my name is Zheng Jianxiong. 
     I graduated from Anhui Medical University. 
     I was born in 1995. 
     I have been engaged in java development for more than a year. I like programming and built my own personal blog. I hope to improve myself and the others‘s life withing technology
Object类中的方法：
     equals:
          很多时候我们需要覆写equals方法，因为不覆写就会调用基类Object的equals方法，比较的是内存地址，这个实际业务中的判定规则不同，所以才需要覆写，代表的就有String类的覆写，只要保证内存地址相同或者字符串内容相同即可
     覆写equals也要覆写hashcode
          因为在很多集合的判定相等的条件中，是先判定hashcode相等，再判定equals是否相等，之所以这么做是为了提高性能，那么当修改equals方法后，hashcode判定相等规则也要改变才能适应新的需求，这里可能有人说，自己用的对象并不需要放入集合，那就不必重写hashcode,事实上也是需要重写的，很多时候集合操作是隐性的，这样出了了错误会很难查询
引用类型：
     > 强引用：类似于Object obj = new Object();语法获取的对象，只要引用存在，GC宁愿抛出异常 也不会回收对象
     > 软引用：非必需对象，当内存溢出时将会被回收，JDK1.2后使用SoftReference来创建
     > 弱引用：非必需对象，存活到下一次GC时，自动被回收，使用WeakReference来创建
     > 虚引用：最弱的引用关系，无法根据引用来获取该对象，使用该引用的目的是为了对象回收时可以收到通知，使用PhantomReference
violate关键字：
     先说结论：volatile关键字的效果在于两点
          保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的
          禁止进行指令重排序     
动态代理的两种方式，以及区别
     静态代理：
     静态的定义是在编译器就确定了代理对象，缺陷是代理类也实现了委托类相同接口再写一边方法，麻烦
     jdk自带的代理：
     实现InvocationHandler接口，接收参数委托类的类加载器，接口class数组，InvocationHandler类class，需要注意的是代理类invoke方法第一个参数为构造入参而不是proxy，调用时使用泛化的接口进行调用，需要什么方法调用什么
     实际上动态生成代理类实现接口数组中的接口，来调用
     cglib代理：
     和jdk自带的一样属于动态代理，区别在于他是以代理对象直接调用，需要注意的是使用Enhancer对象完成代理子类的生成化的方式：
Java序列     
     1. 实体类继承序列化接口，然后使用inputstreamJava原生流(InputStream和OutputStream之间的转化)
     2. jackson
     3. fastjson
传值和传引用的区别，Java是怎么样的，有没有传值引用
     num是基本类型，值就直接保存在变量中。而str是引用类型，变量中保存的只是实际对象的地址。
     一般称这种变量为"引用"，引用指向实际对象，实际对象中保存着内容
     java中都是值传递
     值传递就是传入参数是实际参数的副本，修改不会修改到原参数，
     引用传递是传入的是参数本身，函数内修改会导致函数外对象的改变
JVM内存结构
堆内存
     堆内存是JVM中最大的一块由年轻代和老年代组成，而年轻代内存又被分成三部分，Eden空间、From Survivor空间、To Survivor空间,默认情况下年轻代按照8:1:1的比例来分配；唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。
     方法区存储类信息、常量、静态变量等数据，是线程共享的区域，为与Java堆区分，方法区还有一个别名Non-Heap(非堆)；
方法区：
     用于存储已被虚拟机加载的类信息、常量、静态变量、即使编译后的代码等数据
栈又分为java虚拟机栈和本地方法栈
     主要用于方法的执行,存储的都是和方法执行相关的局部变量，对象引用，区别在于本地方法栈存储的hi执行本地方法相关
     java虚拟机栈存储的是执行java方法
程序计数器：
     每个方法都有，用于记录多线程跳转时的执行位置
GC的常见算法
     引用计数法：
          此对象有一个引用，既增加一个计数器，删除一个引用减少一个计数器，垃圾回收时，只回收计数器为0的对象，
          此算法最致命的是无法处理循环引用的情况
     标记-清除算法：
          首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
          一个是效率问题，标记和清除两个过程的效率都不高 
          另一个是空间问题，标记清除后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后再程序运行过程中需要分配较大对象时，无法找到足够的连续的内存而不得不提前触发另一次垃圾收集动作
     复制算法：
          分割一半内存，整理活着的对象，移到另外一块，清除其他，
     标记-整理算法
          标记过程仍然与”标记-清除”算法一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界意外的内存
     分代收集算法：
          年轻代：使用复制算法
          年老代：标记整理算法
JVM如何判断一个对象是否该被GC：
     根搜索算法：
          把内存中的每一个对象都看作一个节点，并且定义了一些对象作为根节点“GC Roots”。如果一个对象中有另一个对象的引用，那么就认为第一个对象有一条指向第二个对象的边，如下图所示。JVM会起一个线程从所有的GC Roots开始往下遍历，当遍历完之后如果发现有一些对象不可到达，那么就认为这些对象已经没有用了，需要被回收
          GCroot:
               虚拟机栈中的引用的对象
               方法区的静态变量
               常量引用
               本地方法栈对象引用
双亲委派模型：
     某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载
     三个类加载器：
          启动（Bootstrap）类加载器： 
               负责将 <Java_Runtime_Home>/lib下面的类库加载到内存中（比如rt.jar）
          标准扩展（Extension）类加载器：    
               它负责将< Java_Runtime_Home >/lib/ext或者由系统变量 java.ext.dir指定位置中的类库加载到内存中
          系统（System）类加载器：
               它负责将系统类路径（CLASSPATH）中指定的类库加载到内存中
     意义： 防止内存中出现多份同样的字节码 
多线程：
     实现方式：
          1.继承Thread类：单继承
          2.实现Runable接口：多实现
          3.实现Callable接口：多实现有返回值
     Sychronized:
          修饰代码块和方法，锁住调用该代码块的对象
          修饰静态方法或者类，锁住该类的所有对象
          synchronized是在JVM层面上实现的,不但可以通过一些监控工具监控synchronized的锁定,而且在代码执行时出现异常,JVM会释放锁定,但是使用Lock不行,lock是通过代码实现的,要保证锁定一定会被释放,就必须将unlock()放到finally{}中
          在资源竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态
     ThreadLocal：
          ThreadLocal是一个关于创建线程局部变量的类，通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。而使用ThreadLocal创建的变量只能被当前线程访问，其他线程则无法访问和修改
          该对象实际上是存储在堆上只是做了限制
          使用场景
               实现单个线程单例以及单个线程上下文信息存储，比如交易id等
               实现线程安全，非线程安全的对象使用ThreadLocal之后就会变得线程安全，因为每个线程都会有一个对应的实例
               承载一些线程相关的数据，避免在方法中来回传递参数
     线程状态：
          创建，就绪，阻塞，运行，终止
数据库：
     优化：
          1. 尽量不使用null值
          2. 存储字段尽可能的小，状态类可以考虑使用redis存储字典
          3. 适当的使用索引
          4. 图片什么的存储到专门的图片服务器上
          5. 适当使用存储过程
          6. 大数据量分库分表
          7. sql优化
          8. 选择合适的字段
     索引应建立在那些将用于JOIN,WHERE判断和ORDERBY排序的字段上
 Redis：
     支持的数据类型;
          string,hash,list,set,sorted set
     持久化策略：
          RDB:
          快照存储，缺点是自最后一次同步后的数据全部丢失
          AOF:
          已追加的方式来写入文件之中，恢复数据时只需要将步骤再走一遍即可
          appendfsync everysec     #每秒钟强制写入磁盘一次，在性能和持久化方面做了很好的折中，推荐
spring：
     创建自定义注解
          和创建一个接口相似，但是注解的interface关键字需要以@符号开头。
          注解方法不能带有参数；
     java bean就是实体类