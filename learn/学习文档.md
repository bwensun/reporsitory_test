
***
1. [jQuery实现登陆页面](https://www.cnblogs.com/ningvsban/p/3661181.html)

2. restTemplate方法测试
	 常用的请求调用:
	 	getForObject(param1, param2, param3)
	 		第一个参数为string类型url,注意需指定协议，第二个参数为响应体类型，指定对象，基本数据类型为包装类，第三个参数为参数，非必需，在get请求中传递参数有两种方式，1是将参数封装到map集合中（这里使用HashMap就行了，MutiValueMap是不需要的，无效），请求url需要将url末尾以问号拼接的方式对参数赋值传递；2是自第三个参数开始为入参参数值，会按照顺序对url中参数进行一一赋值，两者都需要对url拼接，参数位于url中
	 	postForObject(param1, param2, param3, param4)
	 		第一个参数为string类型url，第二个参数为MutiValueMap类型的map集合,第三个参数为响应体类型，第四个为置于请求url中参数，非必需，对于post请求来说它可以将参数置于请求url中，也可以将参数封装到请求体中，分别对应：1.第二个参数为null，第四个参数为map（HashMap），或者为可变参数列表，url相应也需要修改为拼接模式，和get请求相同；2.第二个参数直接对参数进行赋值（MutiValueMap类型），直接不使用第四个参数，一样可以传递参数。
	 	getForEntity()和getForObject类似，请求参数也是完全相同，仅仅返回类型为ResponseEntity，为完整的响应报文
	 	postForEntity()和postForObject类似，请求参数也是完全相同，仅仅返回类型为ResponseEntity，为完整的响应报文
	 	exchange:（param1, param2, param3, param4）
	 		exchange允许你自定义请求体，请求方法，返回值为ResponseEntity，构建请求体的方法：new 需要httpHeader及MutiValueMap(参数)任意一个或两个构造即可
	 		第一个参数为string类型的url，第二个为枚举请求方式，第三个为请求头，第四个为返回值类型，注意exchange支持直接返回list<T>的类型
	 不常用的方法：
	 	postForLocation; 返回uri,但是测试一直为null
	 	put： 返回值为空
		patch ：类似于get但是可以指定请求方法，返回可以直接是对象
		head： 返回值为header请求头 
		delete： 返回值为空
3. java8流式API：
	为什么引入流式API：在java中对于数据的操作常常是借助数据库来做到的，java自带的集合操作方法是不能对于大数据量的数据进行各种操作，常常要做的就是遍历和遍历，另外java中集合操作无法支持并行执行，流式API的出现可以发挥多核处理器的优势
	构建Stream：
		1. 静态工厂方法(Stream)
			1. of方法：
				IntStream intStream = of(1, 2, 3);
				方法参数也可以将数组或者集合，转换为流
				Java中流对象只有IntStream，DoubleStream和StringStream
				返回有限的流
			2. generate方法：
				该方法用于随机数产生，或者常量Stream等，返回无限长度的流
				最好借助lambda表达式
```java
        Stream<Double> stream2 = Stream.generate(() -> Math.random());
        stream2.filter(x->x<0.50).forEach(x-> System.out.println(x));
        Stream<Double> stream3 = Stream.generate(Math::random);
```	
			3. iterate方法：
				该方法按照一定规则生成无限长度的流，第一个参数为种子，第二个为规则,
```java
        Stream<Integer> iterate = Stream.iterate(1, x -> x * 3);
        iterate.limit(10).forEach(System.out::println);
```
			4. empty:返回一个一个空的流
		2. 集合和数组调用stream()方法
	流的操作：
		流的操作分为两种：
		Intermediate： map 、filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered；
		Terminal：forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、iterator；
		Intermediate中间操作不会导致流的消失，返回值为stream，erminal操作结束后流即消失了，返回值为空
		测试：
			中间操作：
			map：输入流中元素执行操作后一一映射输出流的元素
			filter：条件为布尔值，满足条件的过滤出来
			distinct：去重
			sorted:排序，可以有默认排序，对于对象可以使用制定排序，实现comparetor接口
			peek:对流中的元素执行操作，返回流
			limit:截取前几个元素返回流
			skip:跳过前几个元素返回流
			parallel:对串行流操作获取并行流，并行串行取决于最后的方法是什么，排序时并行可能会造成乱序，并行和串行根据实际情况选用
			sequential:对并行流操作获取串行流
			unordered:
			终端操作：
			forEach:遍历
			min: 求最小值，返回值是optional类型
			max: 求最大值，返回值是optional类型
			count: 求流的元素数，返回值是long
			iterator: 返回迭代器
			collect: 将流的结果处理为定义的类型，这里有两种方法
				通用的方法：
				collect(supplier, accumulator, combiner),三个参数，第一个为想要获取的结果类型，使用new语法获取对象；第二个为将当前元素添加到目标中的方法；第三个为将修改后的对象转为自定义对象方法
				collect重载的方法：对于常用的转换操作有更加简便的方法，list和map显而易见，map集合的测试如下，第一个参数为key的映射，第二个为value的映射，第三个为key相同时的处理策略
```java
        User user1 = new User("张三", "123");
        User user2 = new User("李四", "123");
        User user3 = new User("王五", "123");
        Stream<User> userStream = Stream.of(user1, user2, user3);
        HashMap<String, User> collect = userStream.collect(HashMap<String, User>::new, (map, user) -> map.put(user.getName(), user), HashMap::putAll);
        Map<String, User> collect1 = userStream.collect(Collectors.toMap(user -> user.getName(), user -> user, (x, y) -> y));
***
		Set<Integer> collect = stream1.collect(Collectors.toSet());
       	ArrayList<Object> collect = stream1.distinct().sorted().collect(ArrayList::new, ArrayList::add, ArrayList::addAll);
```		
			reduce:将初始值按照一定的计算模型得到结果，流转换为值
				reduce有三个方法,完整版为reduce(identity, accumulator, combiner),第一个参数为初始值，第二个为迭代操作，第三个为多个迭代结果的合并操作，另外两个方法都是其简略版,(accumulator)和(identity,accumulator)，事实上min,max,count都是reduce操作
```java
        String words = "Never give up, Never lose hope. Always have faith, It allows you to cope. Trying times will pass, As they always do. Just have patience, Your dreams will come true. So put on a smile, You will live through your pain. Know it will pass, And strength you will gain";
        Stream<String> wordStream = Arrays.stream(words.replace(",", "").replace(".", "").split(" "));
 /*       wordStream.reduce((word1, wrod2) ->{
            if (word1.equals(word2)){
                return
            }
        })*/
        Optional<Integer> reduce1 = stream1.reduce((product, x) -> (product * x));
        Integer integer = reduce1.get();
        System.out.println(integer);
        Integer reduce = wordStream.map(x -> x.length()).reduce(0, (sum, length) -> sum + length, (a, b) -> (a + b));
        System.out.println(reduce);
 ```
 	归纳stream特点：
 		1. 惰性，只有当遇到终端操作时才会真的去执行
 		2. 不会修改源数据
 		3. 支持并行操作，流可以是无限的

4. 数据库时间操作函数
		MySQL除法精度定义：truncate(param1, param2) 第一个参数为计算表达式，第二个参数来定义保留的位数，其他均舍去
```sql
	select 
	*,
	(UNIX_TIMESTAMP(NOW()) - UNIX_TIMESTAMP(create_time)),
	TRUNCATE(
		((UNIX_TIMESTAMP(NOW()) - UNIX_TIMESTAMP(create_time))/60), 0)
	FROM t_order_info
	where TRUNCATE(((UNIX_TIMESTAMP(NOW()) - UNIX_TIMESTAMP(create_time))/60), 0) = 30
```
		数据库时间相关的函数：
			UNIX_TIMESTAMP()：无参调用返回当前时间距离1970-01-01 00:00:00的秒数，有参入参可以是任意的时间类型，指定格式的字符串也行，未输入的默认为当前时间，返回当前时间距离1970-01-01 00:00:00的秒数。
			FROM_UNIXTIME():将UNIX时间转换为指定格式字符串
```sql
			SELECT FROM_UNIXTIME(111111,'%Y年%m月%d日 %H时%i分%s秒');
```			
			数据库获取当前时间函数：
				now(): 年月日 时分秒 datetime类型,SQL执行的时刻，SQL中多次获取时间是相同的。
				CURDATE()/CUR_DATE(): 年月日 date类型
				CURTIME()/CUR_TIME(): 时分秒 time类型
				CURTIMSTAMP()CUR_TIMESTAMP: 年月日时分秒 timestamp类型
				SYSDATE(): 年月日 时分秒 datetime,真正意义上的当前时间
			时间差：
				TIMEDIFF(param1,param2):参数均为datetime或者time类型，返回为param1 - param2 差值，为time类型，也就是最大为-838:59:59到838:59:59之间
				DATEDIFF(param1, param2):参数为date或datetime类型，返回param1 - param2差值，类型为天数
				TIMESTAMPDIFF(param1, param2, param3):第一个参数为返回值的类型，可选择的有SECOND,DAY,MONTH,YEAR，param2 param3为timestamp类型
			格式化：
				DATE_FORMAT(param1, param2),param1为时间，param2为时间模板，年月日 时分秒 %Y年%m月%d日 %H时%i分%s秒
				TIME_FORMAT(param1, param2),param1为时间, param2为时间模板, 一切只会读取时分秒
			关于时间:
				UTC:世界协调时间时，也可认为是世界时间，根据自己所在的时区，可以获取当前的标准时间，我们在东九区，UTC+9就是北京时间，UTC是基于原子钟来定义的，先又加入闰秒的概念来应对地球自转变慢的情况
				GMT:格林威治时间，本初子午线测量时，英国皇家学会认为时经过格林威治（英国他自己的小镇，事实上并不经过，经过的是沙特阿拉伯西部的麦加，但当时英国是世界霸主，没人跟他叫板，所以将错就错），他们观测正午太阳位于正上方来定义世界时间，相较而言UTC更精准，但对于我们而言基本是一致的

5. 去空格：
	java中去空格：
		string操作：